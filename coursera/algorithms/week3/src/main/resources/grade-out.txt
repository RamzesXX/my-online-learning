See the Assessment Guide for information on how to interpret this report.

ASSESSMENT SUMMARY

Compilation:  PASSED
API:          PASSED

Findbugs:     FAILED (7 warnings)
PMD:          FAILED (2 warnings)
Checkstyle:   PASSED

Correctness:  27/41 tests passed
Memory:       1/1 tests passed
Timing:       41/41 tests passed

Aggregate score: 79.51%
[Compilation: 5%, API: 5%, Findbugs: 0%, PMD: 0%, Checkstyle: 0%, Correctness: 60%, Memory: 10%, Timing: 20%]

ASSESSMENT DETAILS

The following files were submitted:
----------------------------------
2.3K Aug 28 08:02 BruteCollinearPoints.java
2.8K Aug 28 08:02 FastCollinearPoints.java
1.6K Aug 28 08:02 Point.java


********************************************************************************
*  COMPILING
********************************************************************************


% javac Point.java
*-----------------------------------------------------------

% javac BruteCollinearPoints.java
*-----------------------------------------------------------

% javac FastCollinearPoints.java
*-----------------------------------------------------------


================================================================


Checking the APIs of your programs.
*-----------------------------------------------------------
Point:

BruteCollinearPoints:

FastCollinearPoints:

================================================================


********************************************************************************
*  CHECKING STYLE AND COMMON BUG PATTERNS
********************************************************************************


% findbugs *.class
*-----------------------------------------------------------
M V EI_EXPOSE_REP EI: Returns a reference to the mutable object stored in the instance variable 'segments', which exposes the internal representation of the class 'BruteCollinearPoints'. Instead, create a defensive copy of the object referenced by 'segments' and return the copy.  At BruteCollinearPoints.java:[line 66]
M V EI_EXPOSE_REP2 EI2: Stores a reference to an externally mutable object in the instance variable 'points', exposing the internal representation of the class 'BruteCollinearPoints'. Instead, create a defensive copy of the object referenced by the parameter variable 'points' and store that copy in the instance variable 'points'.   At BruteCollinearPoints.java:[line 18]
L D FE_FLOATING_POINT_EQUALITY FE: Tests for exact floating-point equality. Because floating-point calculations may involve rounding, the calculated values may be imprecise.  At BruteCollinearPoints.java:[line 45]
M V EI_EXPOSE_REP EI: Returns a reference to the mutable object stored in the instance variable 'segments', which exposes the internal representation of the class 'FastCollinearPoints'. Instead, create a defensive copy of the object referenced by 'segments' and return the copy.  At FastCollinearPoints.java:[line 81]
M V EI_EXPOSE_REP2 EI2: Stores a reference to an externally mutable object in the instance variable 'points', exposing the internal representation of the class 'FastCollinearPoints'. Instead, create a defensive copy of the object referenced by the parameter variable 'points' and store that copy in the instance variable 'points'.   At FastCollinearPoints.java:[line 18]
L D FE_FLOATING_POINT_EQUALITY FE: Tests for exact floating-point equality. Because floating-point calculations may involve rounding, the calculated values may be imprecise.  At FastCollinearPoints.java:[line 51]
L P SIC_INNER_SHOULD_BE_STATIC_ANON SIC: Should the anonymous inner class 'Point$1' be refactored into a named static nested class?  At Point.java:[lines 55-64]
The following classes needed for analysis were missing:
  LineSegment226
  Point226
Warnings generated: 7
Missing classes: 2


================================================================


% pmd *.java
*-----------------------------------------------------------
BruteCollinearPoints.java:66: Returning 'segments' may expose an internal array. If so, return a defensive copy. [MethodReturnsInternalArray]
FastCollinearPoints.java:81: Returning 'segments' may expose an internal array. If so, return a defensive copy. [MethodReturnsInternalArray]
PMD ends with 2 warnings.


================================================================


% checkstyle *.java
*-----------------------------------------------------------

% custom checkstyle checks for Point.java
*-----------------------------------------------------------

% custom checkstyle checks for BruteCollinearPoints.java
*-----------------------------------------------------------

% custom checkstyle checks for FastCollinearPoints.java
*-----------------------------------------------------------


================================================================


********************************************************************************
*  TESTING CORRECTNESS
********************************************************************************

Testing correctness of Point
*-----------------------------------------------------------
Running 3 total tests.

Test 1: p.slopeTo(q)
  * positive infinite slope, where p and q have coordinates in [0, 500)
  * positive infinite slope, where p and q have coordinates in [0, 32768)
  * negative infinite slope, where p and q have coordinates in [0, 500)
  * negative infinite slope, where p and q have coordinates in [0, 32768)
  * positive zero     slope, where p and q have coordinates in [0, 500)
  * positive zero     slope, where p and q have coordinates in [0, 32768)
  * symmetric for random points p and q with coordinates in [0, 500)
  * symmetric for random points p and q with coordinates in [0, 32768)
  * transitive for random points p, q, and r with coordinates in [0, 500)
  * transitive for random points p, q, and r with coordinates in [0, 32768)
  * slopeTo(), where p and q have coordinates in [0, 500)
  * slopeTo(), where p and q have coordinates in [0, 32768)
  * slopeTo(), where p and q have coordinates in [0, 10)
  * throw a java.lang.NullPointerException if argument is null
==> passed

Test 2: p.compareTo(q)
  * reflexive, where p and q have coordinates in [0, 500)
  * reflexive, where p and q have coordinates in [0, 32768)
  * antisymmetric, where p and q have coordinates in [0, 500)
  * antisymmetric, where p and q have coordinates in [0, 32768)
  * transitive, where p, q, and r have coordinates in [0, 500)
  * transitive, where p, q, and r have coordinates in [0, 32768)
  * sign of compareTo(), where p and q have coordinates in [0, 500)
  * sign of compareTo(), where p and q have coordinates in [0, 32768)
  * sign of compareTo(), where p and q have coordinates in [0, 10)
  * throw java.lang.NullPointerException exception if argument is null
==> passed

Test 3: p.slopeOrder().compare(q, r)
  * reflexive, where p and q have coordinates in [0, 500)
  * reflexive, where p and q have coordinates in [0, 32768)
  * antisymmetric, where p, q, and r have coordinates in [0, 500)
  * antisymmetric, where p, q, and r have coordinates in [0, 32768)
  * transitive, where p, q, r, and s have coordinates in [0, 500)
  * transitive, where p, q, r, and s have coordinates in [0, 32768)
  * sign of compare(), where p, q, and r have coordinates in [0, 500)
     -  wrong order: slope-ascending, but breaking ties by natural order
     -  slope order depends only on the slope, not on the x- or y-coordinates
  * sign of compare(), where p, q, and r have coordinates in [0, 32768)
  * sign of compare(), where p, q, and r have coordinates in [0, 10)
     -  wrong order: slope-ascending, but breaking ties by natural order
     -  slope order depends only on the slope, not on the x- or y-coordinates
  * throw java.lang.NullPointerException if either argument is null
==> FAILED


Total: 2/3 tests passed!


================================================================
********************************************************************************
*  TESTING CORRECTNESS (substituting reference Point and LineSegment)
********************************************************************************

Testing correctness of BruteCollinearPoints
*-----------------------------------------------------------
Running 17 total tests.

The inputs satisfy the following conditions:
  - no duplicate points
  - no 5 (or more) points are collinear
  - all x- and y-coordinates between 0 and 32,767

Test 1: points from a file
  * filename = input8.txt
  * filename = equidistant.txt
  * filename = input40.txt
  * filename = input48.txt
==> passed

Test 2a: points from a file with horizontal line segments
  * filename = horizontal5.txt
  * filename = horizontal25.txt
==> passed

Test 2b: random horizontal line segments
  *  1 random horizontal line segment
  *  5 random horizontal line segments
  * 10 random horizontal line segments
  * 15 random horizontal line segments
==> passed

Test 3a: points from a file with vertical line segments
  * filename = vertical5.txt
  * filename = vertical25.txt
==> passed

Test 3b: random vertical line segments
  *  1 random vertical line segment
  *  5 random vertical line segments
  * 10 random vertical line segments
  * 15 random vertical line segments
==> passed

Test 4a: points from a file with no line segments
  * filename = random23.txt
  * filename = random38.txt
==> passed

Test 4b: random points with no line segments
  *  5 random points
  * 10 random points
  * 20 random points
  * 50 random points
==> passed

Test 5: points from a file with fewer than 4 points
  * filename = input1.txt
  * filename = input2.txt
  * filename = input3.txt
==> passed

Test 6: check for dependence on either compareTo() or compare()
        returning { -1, +1, 0 } instead of { negative integer,
        positive integer, zero }
  * filename = equidistant.txt
  * filename = input40.txt
  * filename = input48.txt
==> passed

Test 7: check for fragile dependence on return value of toString()
  * filename = equidistant.txt
  * filename = input40.txt
  * filename = input48.txt
==> passed

Test 8: random line segments, none vertical or horizontal
  *  1 random line segment
  *  5 random line segments
  * 10 random line segments
  * 15 random line segments
==> passed

Test 9: random line segments
  *  1 random line segment
  *  5 random line segments
  * 10 random line segments
  * 15 random line segments
==> passed

Test 10: check that data type is immutable by testing whether each method
         returns the same value, regardless of any intervening operations
  * input8.txt
    - failed after 12 operations involving BruteCollinearPoints
    - first and last call to segments() returned different arrays
    - sequence of operations was:
          BruteCollinearPoints collinear = new BruteCollinearPoints(points);
          mutate points[] array that was passed to constructor
          mutate points[] array that was passed to constructor
          mutate points[] array that was passed to constructor
          collinear.segments()
          mutate points[] array that was passed to constructor
          mutate array returned by last call to segments()
          collinear.numberOfSegments() -> 2
          mutate array returned by last call to segments()
          mutate array returned by last call to segments()
          mutate array returned by last call to segments()
          collinear.segments()
    - failed on trial 1 of 100

  * equidistant.txt
    - failed after 13 operations involving BruteCollinearPoints
    - first and last call to segments() returned different arrays
    - sequence of operations was:
          BruteCollinearPoints collinear = new BruteCollinearPoints(points);
          collinear.numberOfSegments() -> 4
          collinear.segments()
          mutate points[] array that was passed to constructor
          mutate array returned by last call to segments()
          mutate array returned by last call to segments()
          collinear.numberOfSegments() -> 4
          mutate array returned by last call to segments()
          mutate array returned by last call to segments()
          collinear.numberOfSegments() -> 4
          mutate points[] array that was passed to constructor
          mutate points[] array that was passed to constructor
          collinear.segments()
    - failed on trial 1 of 100

==> FAILED

Test 11: check that data type does not mutate the constructor argument
  * input8.txt
    - data type mutated the points[] array
    - data type should have no side effects unless documented in API
  * equidistant.txt
    - data type mutated the points[] array
    - data type should have no side effects unless documented in API
==> FAILED

Test 12: numberOfSegments() is consistent with segments()
  * filename = input8.txt
  * filename = equidistant.txt
  * filename = input40.txt
  * filename = input48.txt
  * filename = horizontal5.txt
  * filename = vertical5.txt
  * filename = random23.txt
==> passed

Test 13: throws an exception if either the constructor argument is null
         or any entry in array is null
  * argument is null
  * Point[] of length 10, number of null entries = 1
  * Point[] of length 10, number of null entries = 10
  * Point[] of length 4, number of null entries = 1
  * Point[] of length 3, number of null entries = 1
  * Point[] of length 2, number of null entries = 1
  * Point[] of length 1, number of null entries = 1
==> passed

Test 14: check that the constructor throws an exception if duplicate points
  * 50 points
  * 25 points
  * 5 points
  * 4 points
  * 3 points
  * 2 points
==> passed


Total: 15/17 tests passed!


================================================================
Testing correctness of FastCollinearPoints
*-----------------------------------------------------------
Running 21 total tests.

The inputs satisfy the following conditions:
  - no duplicate points
  - all x- and y-coordinates between 0 and 32,767

Test 1: points from a file
  * filename = input8.txt
  * filename = equidistant.txt
  * filename = input40.txt
  * filename = input48.txt
  * filename = input299.txt
==> passed

Test 2a: points from a file with horizontal line segments
  * filename = horizontal5.txt
    - number of entries in student   solution: 4
    - number of entries in reference solution: 5
    - 1 missing entry in student solution: '(2682, 14118) -> (5067, 14118) -> (7453, 14118) -> (7821, 14118)'


  * filename = horizontal25.txt
    - number of entries in student   solution: 24
    - number of entries in reference solution: 25
    - 1 missing entry in student solution: '(8784, 20913) -> (9880, 20913) -> (16352, 20913) -> (19666, 20913)'


  * filename = horizontal50.txt
    - number of entries in student   solution: 49
    - number of entries in reference solution: 50
    - 1 missing entry in student solution: '(5249, 20754) -> (5559, 20754) -> (14800, 20754) -> (17428, 20754)'


  * filename = horizontal75.txt
    - number of entries in student   solution: 74
    - number of entries in reference solution: 75
    - 1 missing entry in student solution: '(1536, 20976) -> (6545, 20976) -> (14178, 20976) -> (14591, 20976)'


  * filename = horizontal100.txt
    - number of entries in student   solution: 99
    - number of entries in reference solution: 100
    - 1 missing entry in student solution: '(5835, 20698) -> (7673, 20698) -> (16154, 20698) -> (19642, 20698)'


==> FAILED

Test 2b: random horizontal line segments
  *  1 random horizontal line segment
    - number of entries in student   solution: 0
    - number of entries in reference solution: 1
    - 1 missing entry in student solution: '(1468, 5183) -> (11181, 5183) -> (13779, 5183) -> (18465, 5183)'


    - failed on trial 1 of 500
     4
      1468  5183
     18465  5183
     11181  5183
     13779  5183

  *  5 random horizontal line segments
    - number of entries in student   solution: 4
    - number of entries in reference solution: 5
    - 1 missing entry in student solution: '(2290, 17552) -> (2296, 17552) -> (10029, 17552) -> (11959, 17552)'


    - failed on trial 1 of 250
     20
     15649  2891
     19302 12931
      2290 17552
     18621  2891
     10029 17552
     11959 17552
     11731  3279
      4352 12931
      5780  1993
      6912  3279
     17824  2891
     17948  3279
     14737 12931
      4739 12931
      5394  1993
      8753  1993
      3279  2891
      2296 17552
     13200  3279
     11957  1993

  * 10 random horizontal line segments
    - number of entries in student   solution: 9
    - number of entries in reference solution: 10
    - 1 missing entry in student solution: '(4937, 17907) -> (12248, 17907) -> (18608, 17907) -> (20688, 17907)'


    - failed on trial 1 of 50

  * 15 random horizontal line segments
    - number of entries in student   solution: 14
    - number of entries in reference solution: 15
    - 1 missing entry in student solution: '(3367, 20660) -> (15397, 20660) -> (17860, 20660) -> (18858, 20660)'


    - failed on trial 1 of 5

==> FAILED

Test 3a: points from a file with vertical line segments
  * filename = vertical5.txt
  * filename = vertical25.txt
  * filename = vertical50.txt
  * filename = vertical75.txt
  * filename = vertical100.txt
==> passed

Test 3b: random vertical line segments
  *  1 random vertical line segment
    - number of entries in student   solution: 0
    - number of entries in reference solution: 1
    - 1 missing entry in student solution: '(3817, 8563) -> (3817, 11233) -> (3817, 16598) -> (3817, 20890)'


    - failed on trial 1 of 500
     4
      3817 20890
      3817  8563
      3817 16598
      3817 11233

  *  5 random vertical line segments
  * 10 random vertical line segments
  * 15 random vertical line segments
==> FAILED

Test 4a: points from a file with no line segments
  * filename = random23.txt
  * filename = random38.txt
  * filename = random91.txt
  * filename = random152.txt
==> passed

Test 4b: random points with no line segments
  *  5 random points
  * 10 random points
  * 20 random points
  * 50 random points
==> passed

Test 5a: points from a file with 5 or more on some line segments
  * filename = input9.txt
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 1: (2000, 2000) -> (9000, 9000)
    - reference segment 0: (1000, 1000) -> (2000, 2000) -> (3000, 3000) -> (4000, 4000) -> (5000, 5000) -> (6000, 6000) -> (7000, 7000) -> (8000, 8000) -> (9000, 9000)

    - number of entries in student   solution: 5
    - number of entries in reference solution: 1
    - 4 extra entries in student solution, including: '(5000, 5000) -> (9000, 9000)'


  * filename = input10.txt
  * filename = input20.txt
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 2: (5120, 20992) -> (8128, 20992)
    - reference segment 0: (4096, 20992) -> (5120, 20992) -> (6144, 20992) -> (7168, 20992) -> (8128, 20992)

    - number of entries in student   solution: 8
    - number of entries in reference solution: 5
    - 3 extra entries in student solution, including: '(8192, 26112) -> (8192, 29184)'


  * filename = input50.txt
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 3: (1000, 9000) -> (1000, 26000)
    - reference segment 5: (1000, 2000) -> (1000, 9000) -> (1000, 13000) -> (1000, 23000) -> (1000, 26000)

    - number of entries in student   solution: 9
    - number of entries in reference solution: 7
    - 2 extra entries in student solution, including: '(18000, 23000) -> (18000, 30000)'


  * filename = input80.txt
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 20: (16000, 6000) -> (1000, 21000)
    - reference segment 2: (17000, 5000) -> (16000, 6000) -> (12000, 10000) -> (9000, 13000) -> (1000, 21000)

    - number of entries in student   solution: 41
    - number of entries in reference solution: 31
    - 10 extra entries in student solution, including: '(8000, 23000) -> (30000, 23000)'


  * filename = input300.txt
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 5: (7300, 10450) -> (7300, 31650)
    - reference segment 5: (7300, 10050) -> (7300, 10450) -> (7300, 17000) -> (7300, 25700) -> (7300, 31650)

    - number of entries in student   solution: 7
    - number of entries in reference solution: 6
    - 1 extra entry in student solution: '(7300, 10450) -> (7300, 31650)'


  * filename = inarow.txt
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 3: (5000, 0) -> (30000, 0)
    - reference segment 1: (0, 0) -> (5000, 0) -> (10000, 0) -> (15000, 0) -> (20000, 0) -> (25000, 0) -> (30000, 0)

    - number of entries in student   solution: 15
    - number of entries in reference solution: 5
    - 10 extra entries in student solution, including: '(0, 15000) -> (0, 30000)'


==> FAILED

Test 5b: points from a file with 5 or more on some line segments
  * filename = kw1260.txt
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 5: (10470, 316) -> (9837, 685)
    - reference segment 69: (10681, 193) -> (10470, 316) -> (10259, 439) -> (10048, 562) -> (9837, 685)

    - number of entries in student   solution: 645
    - number of entries in reference solution: 288
    - 357 extra entries in student solution, including: '(13180, 30413) -> (14764, 30467)'


  * filename = rs1423.txt
==> FAILED

Test 6: points from a file with fewer than 4 points
  * filename = input1.txt
  * filename = input2.txt
  * filename = input3.txt
==> passed

Test 7: check for dependence on either compareTo() or compare()
        returning { -1, +1, 0 } instead of { negative integer,
        positive integer, zero }
  * filename = equidistant.txt
  * filename = input40.txt
  * filename = input48.txt
  * filename = input299.txt
==> passed

Test 8: check for fragile dependence on return value of toString()
  * filename = equidistant.txt
  * filename = input40.txt
  * filename = input48.txt
==> passed

Test 9: random line segments, none vertical or horizontal
  *  1 random line segment
    - number of entries in student   solution: 0
    - number of entries in reference solution: 1
    - 1 missing entry in student solution: '(6857, 1672) -> (10112, 5062) -> (11414, 6418) -> (15971, 11164)'


    - failed on trial 1 of 500
     4
     10112  5062
     15971 11164
     11414  6418
      6857  1672

  *  5 random line segments
    - number of entries in student   solution: 4
    - number of entries in reference solution: 5
    - 1 missing entry in student solution: '(11491, 12876) -> (12233, 14574) -> (13346, 17121) -> (14088, 18819)'


    - failed on trial 20 of 500
     20
     11491 12876
      7784  9020
      7464 10227
     16402 10216
      7261  9811
      6652  8563
      5434  6067
     12233 14574
     13336 11018
      9864  4618
     10768  5038
     13346 17121
     14176 12516
     11779 11205
     10298  5418
      8128  1418
      9382  9894
     14088 18819
     19219 12805
     11707  5901

  * 25 random line segments
  * 50 random line segments
  * 100 random line segments
==> FAILED

Test 10: random line segments
  *  1 random line segment
    - number of entries in student   solution: 0
    - number of entries in reference solution: 1
    - 1 missing entry in student solution: '(7366, 7145) -> (8468, 10741) -> (8563, 11051) -> (8658, 11361)'


    - failed on trial 1 of 500
     4
      8658 11361
      8468 10741
      7366  7145
      8563 11051

  *  5 random line segments
    - number of entries in student   solution: 4
    - number of entries in reference solution: 5
    - 1 missing entry in student solution: '(13324, 11583) -> (13400, 11679) -> (13438, 11727) -> (13989, 12423)'


    - failed on trial 1 of 500
     20
      5676  5131
     13400 11679
      3903  5367
      7215  6103
      6085  7579
      1056  3316
      6761  7579
      3170 10105
      3953  7579
     13324 11583
      5929  7579
      4880 10656
     13438 11727
      3576  4306
      7863  6247
      4119  5415
     13989 12423
      4340 10482
      3080 10076
      4668  4735

  * 25 random line segments
    - number of entries in student   solution: 24
    - number of entries in reference solution: 25
    - 1 missing entry in student solution: '(3421, 13576) -> (5521, 14026) -> (6445, 14224) -> (7369, 14422)'


    - failed on trial 5 of 100

  * 50 random line segments
  * 100 random line segments
==> FAILED

Test 11: random distinct points in a given range
  * 5 random points in a 10-by-10 grid
    - number of entries in student   solution: 0
    - number of entries in reference solution: 1
    - 1 missing entry in student solution: '(3, 7) -> (4, 7) -> (7, 7) -> (9, 7)'


    - failed on trial 90 of 500
     5
         4     7
         7     7
         8     4
         9     7
         3     7

  * 10 random points in a 10-by-10 grid
    - number of entries in student   solution: 0
    - number of entries in reference solution: 1
    - 1 missing entry in student solution: '(5, 9) -> (6, 9) -> (7, 9) -> (9, 9)'


    - failed on trial 33 of 500
     10
         1     2
         0     1
         2     4
         5     2
         6     9
         9     9
         3     6
         5     9
         7     8
         7     9

  * 50 random points in a 10-by-10 grid
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 4: (2, 0) -> (9, 0)
    - reference segment 11: (1, 0) -> (2, 0) -> (3, 0) -> (5, 0) -> (6, 0) -> (8, 0) -> (9, 0)

    - number of entries in student   solution: 74
    - number of entries in reference solution: 38
    - 36 extra entries in student solution, including: '(1, 8) -> (7, 8)'


    - failed on trial 1 of 100

  * 90 random points in a 10-by-10 grid
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 6: (1, 0) -> (9, 0)
    - reference segment 50: (0, 0) -> (1, 0) -> (2, 0) -> (3, 0) -> (4, 0) -> (5, 0) -> (7, 0) -> (8, 0) -> (9, 0)

    - number of entries in student   solution: 305
    - number of entries in reference solution: 121
    - 184 extra entries in student solution, including: '(4, 9) -> (9, 9)'


    - failed on trial 1 of 50

  * 200 random points in a 50-by-50 grid
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 15: (29, 1) -> (45, 1)
    - reference segment 88: (9, 1) -> (29, 1) -> (34, 1) -> (36, 1) -> (39, 1) -> (45, 1)

    - number of entries in student   solution: 350
    - number of entries in reference solution: 216
    - 134 extra entries in student solution, including: '(21, 49) -> (44, 49)'


    - failed on trial 1 of 10

==> FAILED

Test 12: m*n points on an m-by-n grid
  * 3-by-3 grid
  * 4-by-4 grid
    - number of entries in student   solution: 9
    - number of entries in reference solution: 10
    - 1 missing entry in student solution: '(0, 3) -> (1, 3) -> (2, 3) -> (3, 3)'


  * 5-by-5 grid
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 3: (1, 0) -> (4, 0)
    - reference segment 3: (0, 0) -> (1, 0) -> (2, 0) -> (3, 0) -> (4, 0)

    - number of entries in student   solution: 27
    - number of entries in reference solution: 16
    - 11 extra entries in student solution, including: '(1, 3) -> (4, 3)'


  * 10-by-10 grid
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 9: (1, 0) -> (9, 0)
    - reference segment 67: (0, 0) -> (1, 0) -> (2, 0) -> (3, 0) -> (4, 0) -> (5, 0) -> (6, 0) -> (7, 0) -> (8, 0) -> (9, 0)

    - number of entries in student   solution: 393
    - number of entries in reference solution: 154
    - 239 extra entries in student solution, including: '(5, 9) -> (9, 9)'


  * 20-by-20 grid
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 25: (1, 0) -> (19, 0)
    - reference segment 1203: (0, 0) -> (1, 0) -> (2, 0) -> (3, 0) -> (4, 0) -> (5, 0) -> (6, 0) -> (7, 0) -> (8, 0) -> (9, 0) -> (10, 0) -> (11, 0) -> (12, 0) -> (13, 0) -> (14, 0) -> (15, 0) -> (16, 0) -> (17, 0) -> (18, 0) -> (19, 0)

    - number of entries in student   solution: 5645
    - number of entries in reference solution: 2446
    - 3199 extra entries in student solution, including: '(15, 19) -> (19, 19)'


  * 5-by-4 grid
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 3: (1, 0) -> (4, 0)
    - reference segment 2: (0, 0) -> (1, 0) -> (2, 0) -> (3, 0) -> (4, 0)

    - number of entries in student   solution: 16
    - number of entries in reference solution: 13
    - 3 extra entries in student solution, including: '(1, 2) -> (4, 2)'


  * 6-by-4 grid
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 3: (1, 0) -> (5, 0)
    - reference segment 3: (0, 0) -> (1, 0) -> (2, 0) -> (3, 0) -> (4, 0) -> (5, 0)

    - number of entries in student   solution: 23
    - number of entries in reference solution: 16
    - 7 extra entries in student solution, including: '(1, 3) -> (5, 3)'


  * 10-by-4 grid
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 5: (1, 0) -> (9, 0)
    - reference segment 12: (0, 0) -> (1, 0) -> (2, 0) -> (3, 0) -> (4, 0) -> (5, 0) -> (6, 0) -> (7, 0) -> (8, 0) -> (9, 0)

    - number of entries in student   solution: 61
    - number of entries in reference solution: 38
    - 23 extra entries in student solution, including: '(5, 3) -> (9, 3)'


  * 15-by-4 grid
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 6: (1, 0) -> (14, 0)
    - reference segment 30: (0, 0) -> (1, 0) -> (2, 0) -> (3, 0) -> (4, 0) -> (5, 0) -> (6, 0) -> (7, 0) -> (8, 0) -> (9, 0) -> (10, 0) -> (11, 0) -> (12, 0) -> (13, 0) -> (14, 0)

    - number of entries in student   solution: 122
    - number of entries in reference solution: 79
    - 43 extra entries in student solution, including: '(10, 3) -> (14, 3)'


  * 25-by-4 grid
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 10: (1, 0) -> (24, 0)
    - reference segment 92: (0, 0) -> (1, 0) -> (2, 0) -> (3, 0) -> (4, 0) -> (5, 0) -> (6, 0) -> (7, 0) -> (8, 0) -> (9, 0) -> (10, 0) -> (11, 0) -> (12, 0) -> (13, 0) -> (14, 0) -> (15, 0) -> (16, 0) -> (17, 0) -> (18, 0) -> (19, 0) -> (20, 0) -> (21, 0) -> (22, 0) -> (23, 0) -> (24, 0)

    - number of entries in student   solution: 296
    - number of entries in reference solution: 213
    - 83 extra entries in student solution, including: '(20, 3) -> (24, 3)'


==> FAILED

Test 13: check that data type is immutable by testing whether each method
         returns the same value, regardless of any intervening operations
  * input8.txt
    - failed after 24 operations involving FastCollinearPoints
    - first and last call to segments() returned different arrays
    - failed on trial 1 of 100

  * equidistant.txt
    - failed after 11 operations involving FastCollinearPoints
    - first and last call to segments() returned different arrays
    - sequence of operations was:
          FastCollinearPoints collinear = new FastCollinearPoints(points);
          collinear.numberOfSegments() -> 4
          mutate points[] array that was passed to constructor
          mutate points[] array that was passed to constructor
          collinear.segments()
          mutate points[] array that was passed to constructor
          collinear.numberOfSegments() -> 4
          mutate array returned by last call to segments()
          collinear.numberOfSegments() -> 4
          collinear.numberOfSegments() -> 4
          collinear.segments()
    - failed on trial 1 of 100

==> FAILED

Test 14: check that data type does not mutate the constructor argument
  * input8.txt
    - data type mutated the points[] array
    - data type should have no side effects unless documented in API
  * equidistant.txt
    - data type mutated the points[] array
    - data type should have no side effects unless documented in API
==> FAILED

Test 15: numberOfSegments() is consistent with segments()
  * filename = input8.txt
  * filename = equidistant.txt
  * filename = input40.txt
  * filename = input48.txt
  * filename = horizontal5.txt
  * filename = vertical5.txt
  * filename = random23.txt
==> passed

Test 16: throws an exception if either constructor argument is null
         or any entry in array is null
  * argument is null
  * Point[] of length 10, number of null entries = 1
  * Point[] of length 10, number of null entries = 10
  * Point[] of length 4, number of null entries = 1
  * Point[] of length 3, number of null entries = 1
  * Point[] of length 2, number of null entries = 1
  * Point[] of length 1, number of null entries = 1
==> passed

Test 17: check that the constructor throws an exception if duplicate points
  * 50 points
  * 25 points
  * 5 points
  * 4 points
  * 3 points
  * 2 points
==> passed


Total: 10/21 tests passed!


================================================================
********************************************************************************
*  MEMORY
********************************************************************************

Analyzing memory of Point
*-----------------------------------------------------------
Running 1 total tests.

The maximum amount of memory per Point object is 32 bytes.

Student memory = 24 bytes (passed)

Total: 1/1 tests passed!

================================================================



********************************************************************************
*  TIMING
********************************************************************************

Timing BruteCollinearPoints
*-----------------------------------------------------------
Running 10 total tests.

Test 1a-1e: Find collinear points among n random distinct points


                                                      slopeTo()
             n    time     slopeTo()   compare()  + 2*compare()        compareTo()
-----------------------------------------------------------------------------------------------
=> passed    16   0.00        3640           0           3640                   63
=> passed    32   0.00       71920           0          71920                  159
=> passed    64   0.01     1270752           0        1270752                  365
=> passed   128   0.02    21336000           0       21336000                  869
=> passed   256   0.36   349585280           0      349585280                 1971
==> 5/5 tests passed

Test 2a-2e: Find collinear points among n/4 arbitrary line segments


                                                      slopeTo()
             n    time     slopeTo()   compare()  + 2*compare()        compareTo()
-----------------------------------------------------------------------------------------------
=> passed    16   0.00        3818           0           3818                   60
=> passed    32   0.00       72664           0          72664                  156
=> passed    64   0.01     1274310           0        1274310                  370
=> passed   128   0.13    21348872           0       21348872                  863
=> passed   256   1.71   349639612           0      349639612                 1989
==> 5/5 tests passed

Total: 10/10 tests passed!


================================================================



Timing FastCollinearPoints
*-----------------------------------------------------------
Running 31 total tests.

Test 1a-1g: Find collinear points among n random distinct points


                                                      slopeTo()
             n    time     slopeTo()   compare()  + 2*compare()        compareTo()
-----------------------------------------------------------------------------------------------
=> passed    64   0.01        3960        8032          20024                  361
=> passed   128   0.01       16120       39615          95350                  857
=> passed   256   0.01       65016      187966         440948                 2005
=> passed   512   0.06      261112      868792        1998696                 4481
=> passed  1024   0.24     1046518     3964462        8975442                 9980
=> passed  2048   0.46     4190167    17835412       39860991                22027
==> 6/6 tests passed

lg ratio(slopeTo() + 2*compare()) = lg (39860991 / 8975442) = 2.15
=> passed

==> 7/7 tests passed

Test 2a-2g: Find collinear points among the n points on an n-by-1 grid

                                                      slopeTo()
             n    time     slopeTo()   compare()  + 2*compare()        compareTo()
-----------------------------------------------------------------------------------------------
=> passed    64   0.00        2010        1950           5910                  367
=> passed   128   0.00        8122        7998          24118                  863
=> passed   256   0.00       32634       32382          97398                 1998
=> passed   512   0.00      130810      130302         391414                 4485
=> passed  1024   0.02      523770      522750        1569270                10016
=> passed  2048   0.06     2096122     2094078        6284278                22037
=> passed  4096   0.17     8386554     8382462       25151478                48152
==> 7/7 tests passed

lg ratio(slopeTo() + 2*compare()) = lg (25151478 / 6284278) = 2.00
=> passed

==> 8/8 tests passed

Test 3a-3g: Find collinear points among the n points on an n/4-by-4 grid

                                                      slopeTo()
             n    time     slopeTo()   compare()  + 2*compare()        compareTo()
-----------------------------------------------------------------------------------------------
=> passed    64   0.00        3201        6973          17147                  359
=> passed   128   0.00       12897       26474          65845                  863
=> passed   256   0.00       51745       69825         191395                 1997
=> passed   512   0.01      207265      245901         699067                 4491
=> passed  1024   0.03      829601      927947        2685495                 9963
=> passed  2048   0.09     3319457     3607524       10534505                22042
=> passed  4096   0.35    13279905    14220879       41721663                48167
==> 7/7 tests passed

lg ratio(slopeTo() + 2*compare()) = lg (41721663 / 10534505) = 1.99
=> passed

==> 8/8 tests passed

Test 4a-4g: Find collinear points among the n points on an n/8-by-8 grid

                                                      slopeTo()
             n    time     slopeTo()   compare()  + 2*compare()        compareTo()
-----------------------------------------------------------------------------------------------
=> passed    64   0.00        3229        7698          18625                  368
=> passed   128   0.00       13039       35863          84765                  869
=> passed   256   0.00       52339      127117         306573                 1998
=> passed   512   0.01      209675      385255         980185                 4500
=> passed  1024   0.03      839265     1438623        3716511                10016
=> passed  2048   0.12     3358145     5568214       14494573                22030
=> passed  4096   0.39    13434685    21899883       57234451                48094
==> 7/7 tests passed

lg ratio(slopeTo() + 2*compare()) = lg (57234451 / 14494573) = 1.98
=> passed

==> 8/8 tests passed

Total: 31/31 tests passed!